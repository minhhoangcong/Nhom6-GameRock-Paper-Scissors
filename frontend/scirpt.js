let ws;
let playerId;
let playerName = "";
let currentRoom = null;
let gameHistory = [];
let isWaitingForOpponent = false;
let currentChoice = null;
let isReady = false;
let isBotMode = false;
let botSeriesBestOf = 3; // Bo3
let botSeriesWins = { me: 0, bot: 0 };
let botSeriesOver = false;
let countdownInterval = null;
let timeLeft = 10;
let hasChosenThisRound = false;
let latestRooms = [];
let pingTimer = null;
let lastPingTs = 0;
let bgmEnabled = true; // cho ph√©p nh·∫°c n·ªÅn
let sfxEnabled = true; // cho ph√©p hi·ªáu ·ª©ng (click, win/lose/draw)
let lastPvpSeries = null; // nh·ªõ series PvP m·ªõi nh·∫•t ƒë·ªÉ render l·∫°i khi c·∫ßn

// Kh·ªüi t·∫°o k·∫øt n·ªëi WebSocket
function initWebSocket() {
  ws = new WebSocket("ws://localhost:8082");

  ws.onopen = () => {
    console.log("ƒê√£ k·∫øt n·ªëi v·ªõi server");
    showNotification("ƒê√£ k·∫øt n·ªëi v·ªõi server", "success");
    refreshRooms();
    startPing();
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    handleServerMessage(data);
  };

  ws.onclose = () => {
    console.log("M·∫•t k·∫øt n·ªëi v·ªõi server");
    showNotification(
      "M·∫•t k·∫øt n·ªëi v·ªõi server. ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...",
      "error"
    );
    stopPing();
    setTimeout(initWebSocket, 3000);
  };

  ws.onerror = (error) => {
    console.error("L·ªói WebSocket:", error);
    showNotification("L·ªói k·∫øt n·ªëi", "error");
  };
}

// X·ª≠ l√Ω tin nh·∫Øn t·ª´ server
function handleServerMessage(data) {
  switch (data.type) {
    case "player_id":
      playerId = data.player_id;
      document.getElementById(
        "player-id"
      ).textContent = `Ng∆∞·ªùi ch∆°i ${playerId}`;
      break;

    case "rooms_list":
      latestRooms = Array.isArray(data.rooms) ? data.rooms : [];
      updateRoomsList(latestRooms);
      break;

    case "room_created":
      currentRoom = data.room;
      showGameRoom();
      showReadyButton(); // Hi·ªÉn th·ªã n√∫t s·∫µn s√†ng khi t·∫°o ph√≤ng
      showNotification("ƒê√£ t·∫°o ph√≤ng th√†nh c√¥ng!", "success");
      break;

    case "player_joined":
      console.log("Nh·∫≠n th√¥ng b√°o player_joined:", data);
      currentRoom = data.room;
      updateRoomInfo(data.room);
      showGameRoom(); // ƒê·∫£m b·∫£o chuy·ªÉn sang m√†n h√¨nh ph√≤ng
      showReadyButton(); // Hi·ªÉn th·ªã n√∫t s·∫µn s√†ng khi c√≥ ng∆∞·ªùi tham gia
      showNotification(`${data.player_name} ƒë√£ tham gia ph√≤ng`, "info");
      break;

    case "player_left":
      currentRoom = data.room;
      updateRoomInfo(data.room);
      showNotification(`${data.player_name} ƒë√£ r·ªùi ph√≤ng`, "info");
      break;

    case "player_ready":
      currentRoom = data.room;
      updateRoomInfo(data.room);
      showNotification(`${data.player_name} ƒë√£ s·∫µn s√†ng`, "info");
      break;

    case "game_start": {
      const { room, series } = data;
      currentRoom = room;
      updateRoomInfo(room);
      clearChoiceSelection();
      hideNewGameButton();
      hideReadyButton(); // v√†o v√°n th√¨ ·∫©n Ready
      enableChoices();
      isWaitingForOpponent = false;
      updateGameStatus("Tr√≤ ch∆°i b·∫Øt ƒë·∫ßu! H√£y ch·ªçn k√©o/b√∫a/bao.");

      try {
        stopBGM && stopBGM();
      } catch {}

      // üïí ƒê·∫øm ng∆∞·ª£c 10s
      startCountdownTimer(10);

      // üî• Bo3 PvP: n·∫øu server g·ª≠i series th√¨ l∆∞u + hi·ªÉn th·ªã
      if (!isBotMode && series) {
        lastPvpSeries = series;
        updateSeriesUIPvp(series);
      } else if (!isBotMode && lastPvpSeries) {
        // ph√≤ng h·ªù: n·∫øu v√¨ l√Ω do g√¨ game_start ch∆∞a k√®m series,
        // ta v·∫´n hi·ªÉn th·ªã l·∫°i series g·∫ßn nh·∫•t ƒë·ªÉ kh√¥ng "m·∫•t" d√≤ng Bo3
        updateSeriesUIPvp(lastPvpSeries);
      }

      showNotification("Tr√≤ ch∆°i b·∫Øt ƒë·∫ßu!", "success");
      break;
    }

    case "player_chose":
      updateGameStatus(`${data.player_name} ƒë√£ ch·ªçn l·ª±a`);
      break;

    case "game_result": {
      // D·ª´ng ƒë·ªìng h·ªì + hi·ªÉn th·ªã k·∫øt qu·∫£, ƒëi·ªÉm... (h√†m c≈© c·ªßa b·∫°n)
      handleGameResult(data);

      // üî• C·∫≠p nh·∫≠t Bo3 PvP ch·∫Øc ch·∫Øn theo payload t·ª´ server
      if (!isBotMode && data.series) {
        lastPvpSeries = data.series;
        updateSeriesUIPvp(data.series);
        const btn = document.getElementById("new-game-btn");
        if (btn) {
          btn.textContent = data.series.over
            ? "üîÑ B·∫Øt ƒë·∫ßu series m·ªõi"
            : "üîÑ Ch∆°i l·∫°i (v√≤ng k·∫ø)";
        }
      }
      break;
    }

    case "player_ready_for_new_game":
      currentRoom = data.room;
      updateRoomInfo(data.room);
      showNotification(`${data.player_name} ƒë√£ s·∫µn s√†ng ch∆°i l·∫°i`, "info");
      break;

    case "room_updated":
      currentRoom = data.room;
      updateRoomInfo(data.room);
      break;

    case "error":
      showNotification(`L·ªói: ${data.message}`, "error");
      // N·∫øu l·ªói khi tham gia ph√≤ng, l√†m m·ªõi danh s√°ch ph√≤ng
      if (
        data.message.includes("Ph√≤ng") ||
        data.message.includes("ƒë√£ ·ªü trong ph√≤ng") ||
        data.message.includes("ƒë√£ ƒë·∫ßy")
      ) {
        refreshRooms();
      }
      break;
    case "chat":
      addChatMessage(data.player_name, data.message);
      break;
    case "pong":
      const rtt = Date.now() - (data.t || Date.now());
      updatePingUI(rtt);
      break;
  }
}

    // C·∫≠p nh·∫≠t danh s√°ch ph√≤ng
    function updateRoomsList(rooms) {
        const roomsList = document.getElementById('rooms-list');
        
        if (rooms.length === 0) {
            roomsList.innerHTML = '<div class="loading">Kh√¥ng c√≥ ph√≤ng n√†o. H√£y t·∫°o ph√≤ng m·ªõi!</div>';
            return;
        }
        
        roomsList.innerHTML = rooms.map(room => {
            const isFull = room.current_players >= 2; // Lu√¥n l√† 2 ng∆∞·ªùi
            const canJoin = !isFull && room.current_players < 2;
            
            return `
                <div class="room-card ${isFull ? 'full' : ''}" onclick="${isFull ? '' : `joinRoom('${room.room_id}')`}">
                    <div class="room-header">
                        <div class="room-name">${room.room_name}</div>
                        <div class="room-status">${getGameStateText(room.game_state)}</div>
                    </div>
                    <div class="room-players">
                        <span>üë• ${room.current_players}/2 ng∆∞·ªùi ch∆°i</span>
                        ${canJoin ? '<button class="join-btn" onclick="event.stopPropagation(); joinRoom(\'' + room.room_id + '\')">Tham gia</button>' : '<span style="color: #dc3545;">ƒê√£ ƒë·∫ßy</span>'}
                    </div>
                    <div class="room-players">
                        <span>Ng∆∞·ªùi ch∆°i: ${room.players.map(p => p.name).join(', ')}</span>
                    </div>
                </div>
            `;
        }).join('');
    }

// L·∫•y text tr·∫°ng th√°i game
function getGameStateText(state) {
  switch (state) {
    case "waiting":
      return "‚è≥ Ch·ªù ng∆∞·ªùi ch∆°i";
    case "playing":
      return "üéÆ ƒêang ch∆°i";
    case "finished":
      return "üèÅ K·∫øt th√∫c";
    default:
      return "‚ùì Kh√¥ng x√°c ƒë·ªãnh";
  }
}

// T·∫°o ph√≤ng m·ªõi
function createRoom() {
    const roomName = document.getElementById('room-name').value.trim() || `Ph√≤ng ${Date.now()}`;
    
    ws.send(JSON.stringify({
        type: 'create_room',
        room_name: roomName,
        max_players: 2  // Lu√¥n t·∫°o ph√≤ng 2 ng∆∞·ªùi
    }));
}

// Tham gia ph√≤ng
function joinRoom(roomId) {
  console.log("ƒêang tham gia ph√≤ng:", roomId);
  ws.send(
    JSON.stringify({
      type: "join_room",
      room_id: roomId,
    })
  );
}

// R·ªùi ph√≤ng
function leaveRoom() {
  const box = document.getElementById("series-status");
  if (box) box.style.display = "none";
  ws.send(
    JSON.stringify({
      type: "leave_room",
    })
  );

  currentRoom = null;
  isBotMode = false;
  showMainScreen();
  startBGMIfNeeded(); // üîä V·ªÅ menu th√¨ b·∫≠t l·∫°i nh·∫°c (n·∫øu ƒëang B·∫≠t)
  showNotification("ƒê√£ r·ªùi ph√≤ng", "info");
  refreshRooms(); // L√†m m·ªõi danh s√°ch ph√≤ng
}

// ƒê·∫∑t t√™n ng∆∞·ªùi ch∆°i
function setPlayerName() {
  const nameInput = document.getElementById("player-name");
  const name = nameInput.value.trim();

  if (name.length < 2) {
    showNotification("T√™n ph·∫£i c√≥ √≠t nh·∫•t 2 k√Ω t·ª±", "error");
    return;
  }

  playerName = name;
  ws.send(
    JSON.stringify({
      type: "set_name",
      name: name,
    })
  );

  showNotification("ƒê√£ c·∫≠p nh·∫≠t t√™n", "success");
}

// Toggle s·∫µn s√†ng
function toggleReady() {
  isReady = !isReady;
  const readyBtn = document.getElementById("ready-btn");

  if (isReady) {
    readyBtn.textContent = "‚è∏Ô∏è H·ªßy s·∫µn s√†ng";
    readyBtn.classList.add("ready");

    if (isBotMode) {
      currentRoom.game_state = "playing";
      currentRoom.players.forEach((p) => (p.ready = true));
      updateRoomInfo(currentRoom);

      hideReadyButton();
      enableChoices();
      startCountdownTimer(10); // n·∫øu b·∫°n mu·ªën ƒë·∫øm ng∆∞·ª£c nh∆∞ PvP
      updateGameStatus("Tr√≤ ch∆°i b·∫Øt ƒë·∫ßu! H√£y ch·ªçn K√©o/B√∫a/Bao.");
      return;
    }
    // PvP
    ws.send(JSON.stringify({ type: "ready" }));
  } else {
    readyBtn.textContent = "‚úÖ S·∫µn s√†ng";
    readyBtn.classList.remove("ready");
  }
}

// L√†m m·ªõi danh s√°ch ph√≤ng
function refreshRooms() {
  ws.send(JSON.stringify({ type: "get_rooms" }));
}

// Hi·ªÉn th·ªã m√†n h√¨nh ch√≠nh
function showMainScreen() {
  document
    .querySelectorAll(".screen")
    .forEach((screen) => screen.classList.remove("active"));
  document.getElementById("main-screen").classList.add("active");
}

// Hi·ªÉn th·ªã m√†n h√¨nh t·∫°o ph√≤ng
function showCreateRoom() {
  document
    .querySelectorAll(".screen")
    .forEach((screen) => screen.classList.remove("active"));
  document.getElementById("create-room-screen").classList.add("active");
}

// Hi·ªÉn th·ªã m√†n h√¨nh ph√≤ng ch∆°i
function showGameRoom() {
  document
    .querySelectorAll(".screen")
    .forEach((screen) => screen.classList.remove("active"));
  document.getElementById("game-room-screen").classList.add("active");
  updateRoomInfo(currentRoom);
}

// C·∫≠p nh·∫≠t th√¥ng tin ph√≤ng
function updateRoomInfo(room) {
  if (!isBotMode && lastPvpSeries) updateSeriesUIPvp(lastPvpSeries);
  if (!room) return;

  currentRoom = room;
  document.getElementById("room-name").textContent = room.room_name;

  // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i v·ªõi layout 2 ng∆∞·ªùi ƒë·ªëi di·ªán
  const playersList = document.getElementById("players-list");
  let playersHTML = "";

  // T·∫°o 2 v·ªã tr√≠ c·ªë ƒë·ªãnh cho 2 ng∆∞·ªùi ch∆°i
  const leftPlayer = room.players[0] || null;
  const rightPlayer = room.players[1] || null;

  // Ng∆∞·ªùi ch∆°i b√™n tr√°i
  if (leftPlayer) {
    const isCurrentPlayer = leftPlayer.player_id === playerId;
    const playerClass = isCurrentPlayer ? "current-player" : "other-player";

    playersHTML += `
                <div class="player-item ${playerClass} left-side">
                    <div class="player-avatar">${leftPlayer.name
                      .charAt(0)
                      .toUpperCase()}</div>
                    <div class="player-info">
                        <span class="player-name">${leftPlayer.name}</span>
                        <span class="player-status ${
                          leftPlayer.ready ? "ready" : "waiting"
                        }">
                            ${leftPlayer.ready ? "‚úÖ S·∫µn s√†ng" : "‚è≥ Ch·ªù"}
                        </span>
                    </div>
                </div>
            `;
  } else {
    // V·ªã tr√≠ tr·ªëng b√™n tr√°i
    playersHTML += `
                <div class="player-item empty-player left-side">
                    <div class="player-avatar">?</div>
                    <div class="player-info">
                        <span class="player-name">Ch·ªù ng∆∞·ªùi ch∆°i</span>
                        <span class="player-status waiting">‚è≥ Tr·ªëng</span>
                    </div>
                </div>
            `;
  }

  // Ng∆∞·ªùi ch∆°i b√™n ph·∫£i
  if (rightPlayer) {
    const isCurrentPlayer = rightPlayer.player_id === playerId;
    const playerClass = isCurrentPlayer ? "current-player" : "other-player";

    playersHTML += `
                <div class="player-item ${playerClass} right-side">
                    <div class="player-avatar">${rightPlayer.name
                      .charAt(0)
                      .toUpperCase()}</div>
                    <div class="player-info">
                        <span class="player-name">${rightPlayer.name}</span>
                        <span class="player-status ${
                          rightPlayer.ready ? "ready" : "waiting"
                        }">
                            ${rightPlayer.ready ? "‚úÖ S·∫µn s√†ng" : "‚è≥ Ch·ªù"}
                        </span>
                    </div>
                </div>
            `;
  } else {
    // V·ªã tr√≠ tr·ªëng b√™n ph·∫£i
    playersHTML += `
                <div class="player-item empty-player right-side">
                    <div class="player-avatar">?</div>
                    <div class="player-info">
                        <span class="player-name">Ch·ªù ng∆∞·ªùi ch∆°i</span>
                        <span class="player-status waiting">‚è≥ Tr·ªëng</span>
                    </div>
                </div>
            `;
  }

  playersList.innerHTML = playersHTML;

  // C·∫≠p nh·∫≠t b·∫£ng ƒëi·ªÉm
  updateScoreboard(room);

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i game
  if (room.game_state === "playing") {
    updateGameStatus("Tr√≤ ch∆°i ƒëang di·ªÖn ra!");
    enableChoices();
  } else {
    updateGameStatus("Ch·ªù ng∆∞·ªùi ch∆°i s·∫µn s√†ng...");
    disableChoices();
  }
}
//helper
function getMyServerName() {
  // ∆Øu ti√™n t√™n do server ƒëang gi·ªØ cho ch√≠nh b·∫°n trong ph√≤ng
  if (currentRoom && Array.isArray(currentRoom.players)) {
    const me = currentRoom.players.find((p) => p.player_id === playerId);
    if (me)
      return me.name || me.player_name || playerName || `Player_${playerId}`;
  }
  // D·ª± ph√≤ng: n·∫øu ch∆∞a c√≥ room/players
  return playerName || `Player_${playerId}`;
}

// X·ª≠ l√Ω k·∫øt qu·∫£ game
function handleGameResult(data) {
    const { choices, results, scores } = data;
    
    console.log('Nh·∫≠n game_result:', data);
    console.log('Scores nh·∫≠n ƒë∆∞·ª£c:', scores);
    
    // Hi·ªÉn th·ªã k·∫øt qu·∫£
    const choiceNames = {
        'rock': 'B√∫a ü™®',
        'paper': 'Bao üìÑ', 
        'scissors': 'K√©o ‚úÇÔ∏è'
    };
    
    let resultText = "K·∫øt qu·∫£:\n";
    for (const [playerName, choice] of Object.entries(choices)) {
        resultText += `${playerName}: ${choiceNames[choice]}\n`;
    }
    resultText += "\nK·∫øt qu·∫£:\n";
    for (const [playerName, result] of Object.entries(results)) {
        const resultEmoji = result === 'win' ? 'üéâ' : result === 'lose' ? 'üòî' : 'ü§ù';
        resultText += `${playerName}: ${resultEmoji} ${getResultText(result)}\n`;
    }
    
    updateGameResult(resultText);
    
    // Th√™m v√†o l·ªãch s·ª≠
    addToHistory(choices, results);
    
    // C·∫≠p nh·∫≠t b·∫£ng ƒëi·ªÉm v·ªõi ƒëi·ªÉm s·ªë m·ªõi
    if (currentRoom && scores) {
        console.log('C·∫≠p nh·∫≠t scores cho currentRoom:', scores);
        currentRoom.scores = scores;
        updateScoreboard(currentRoom);
    }
    
    // Hi·ªÉn th·ªã n√∫t ch∆°i l·∫°i v√† ·∫©n n√∫t s·∫µn s√†ng
    showNewGameButton();
    hideReadyButton();
    
    // Reset tr·∫°ng th√°i v√† t·∫Øt c√°c n√∫t l·ª±a ch·ªçn
    isWaitingForOpponent = false;
    currentChoice = null;
    clearChoiceSelection();
    isReady = false;
    disableChoices(); // T·∫Øt c√°c n√∫t l·ª±a ch·ªçn cho ƒë·∫øn khi c·∫£ 2 b·∫•m ch∆°i l·∫°i
    
    updateGameStatus("Tr·∫≠n ƒë·∫•u k·∫øt th√∫c! B·∫•m 'Ch∆°i l·∫°i' ƒë·ªÉ b·∫Øt ƒë·∫ßu v√≤ng m·ªõi");
}

// C·∫≠p nh·∫≠t b·∫£ng ƒëi·ªÉm
function updateScoreboard(room) {
  const scoreboard = document.getElementById("scoreboard");
  if (!scoreboard || !room.scores) {
    console.log("Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t scoreboard:", {
      scoreboard: !!scoreboard,
      scores: !!room.scores,
    });
    return;
  }

  console.log("C·∫≠p nh·∫≠t scoreboard v·ªõi room:", room);
  console.log("Scores trong room:", room.scores);

  let scoreboardHTML = "";

  // T√¨m ng∆∞·ªùi th·∫Øng v√† thua d·ª±a tr√™n ƒëi·ªÉm s·ªë
  let winner = null;
  let loser = null;
  let isDraw = false;

  const playerNames = Object.keys(room.scores);
  if (playerNames.length === 2) {
    const player1 = room.scores[playerNames[0]];
    const player2 = room.scores[playerNames[1]];

    if (player1.wins > player2.wins) {
      winner = playerNames[0];
      loser = playerNames[1];
    } else if (player2.wins > player1.wins) {
      winner = playerNames[1];
      loser = playerNames[0];
    } else if (player1.losses > player2.losses) {
      winner = playerNames[1];
      loser = playerNames[0];
    } else if (player2.losses > player1.losses) {
      winner = playerNames[0];
      loser = playerNames[1];
    } else {
      isDraw = true; // H√≤a
    }
  }

  // Hi·ªÉn th·ªã ƒëi·ªÉm s·ªë cho t·ª´ng ng∆∞·ªùi ch∆°i
  for (const [playerName, score] of Object.entries(room.scores)) {
    console.log("X·ª≠ l√Ω player:", playerName, "score:", score);

    // T√¨m player_id c·ªßa ng∆∞·ªùi ch∆°i n√†y ƒë·ªÉ so s√°nh
    let isCurrentPlayer = false;
    for (const player of room.players) {
      if (player.name === playerName && player.player_id === playerId) {
        isCurrentPlayer = true;
        break;
      }
    }

    // X√°c ƒë·ªãnh class cho m√†u s·∫Øc
    let playerClass = isCurrentPlayer ? "current-player" : "";
    if (!isDraw) {
      if (playerName === winner) {
        playerClass += " winner";
      } else if (playerName === loser) {
        playerClass += " loser";
      }
    }

    scoreboardHTML += `
            <div class="score-item ${playerClass}">
                <div class="player-info">
                    <div class="player-avatar">${playerName
                      .charAt(0)
                      .toUpperCase()}</div>
                    <div class="player-name">${playerName}</div>
                </div>
                <div class="score-stats">
                    <div class="score-stat wins">
                        <span>üèÜ</span>
                        <span>${score.wins}</span>
                    </div>
                    <div class="score-stat losses">
                        <span>üíî</span>
                        <span>${score.losses}</span>
                    </div>
                    <div class="score-stat draws">
                        <span>ü§ù</span>
                        <span>${score.draws}</span>
                    </div>
                </div>
            </div>
        `;
  }

  console.log("Scoreboard HTML:", scoreboardHTML);
  scoreboard.innerHTML = scoreboardHTML;
}

function requestNewGame() {
  // BOT MODE
  if (currentRoom && currentRoom.room_name === "B·∫°n vs M√°y") {
    clearCountdownTimer();
    clearChoiceSelection();
    hideNewGameButton();

    if (botSeriesOver) {
      // B·∫ÆT ƒê·∫¶U SERIES M·ªöI
      botSeriesWins = { me: 0, bot: 0 };
      botSeriesOver = false;
      updateSeriesUIBot();
      updateGameResult("");
      updateGameStatus("B·∫•m 'S·∫µn s√†ng' ƒë·ªÉ b·∫Øt ƒë·∫ßu series m·ªõi v·ªõi Bot.");
      // Tr·ªü l·∫°i tr·∫°ng th√°i ch·ªù
      currentRoom.game_state = "waiting";
      currentRoom.players.forEach((p) => (p.ready = false));
      showReadyButton();
      disableChoices();
    } else {
      // V√ÅN TI·∫æP THEO TRONG SERIES
      currentRoom.game_state = "playing";
      hasChosenThisRound = false;
      currentChoice = null;
      updateGameResult("");
      updateGameStatus(
        `Bo${botSeriesBestOf} ‚Äî V√°n k·∫ø ti·∫øp: h√£y ch·ªçn K√©o/B√∫a/Bao.`
      );
      enableChoices();
      startCountdownTimer(10);
    }
    return;
  }

  // PVP
  ws.send(JSON.stringify({ type: "new_game" }));
  updateGameStatus("ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c b·∫•m 'Ch∆°i l·∫°i'.");
  hideNewGameButton();
  clearChoiceSelection();
  disableChoices();
}

// C·∫≠p nh·∫≠t tr·∫°ng th√°i game
function updateGameStatus(message) {
  document.getElementById("game-status").textContent = message;
}

// C·∫≠p nh·∫≠t k·∫øt qu·∫£ game
function updateGameResult(message) {
  document.getElementById("game-result").textContent = message;
}

// B·∫≠t c√°c n√∫t l·ª±a ch·ªçn
function enableChoices() {
  document.querySelectorAll(".choice-btn").forEach((btn) => {
    btn.disabled = false;
    btn.style.opacity = "1";
  });
}

// T·∫Øt c√°c n√∫t l·ª±a ch·ªçn
function disableChoices() {
  document.querySelectorAll(".choice-btn").forEach((btn) => {
    btn.disabled = true;
    btn.style.opacity = "0.5";
  });
}

// Ch·ªçn l·ª±a ch·ªçn
function selectChoice(choice) {
  clearChoiceSelection();
  const btn = document.getElementById(`${choice}-btn`);
  if (btn) {
    btn.classList.add("selected");
  }
}

// X√≥a l·ª±a ch·ªçn ƒë√£ ch·ªçn
function clearChoiceSelection() {
  document.querySelectorAll(".choice-btn").forEach((btn) => {
    btn.classList.remove("selected");
  });
}

// Hi·ªÉn th·ªã n√∫t ch∆°i l·∫°i
function showNewGameButton() {
  document.getElementById("new-game-btn").style.display = "block";
}

// ·∫®n n√∫t ch∆°i l·∫°i
function hideNewGameButton() {
  document.getElementById("new-game-btn").style.display = "none";
}

// ·∫®n n√∫t s·∫µn s√†ng
function hideReadyButton() {
  const readyBtn = document.getElementById("ready-btn");
  readyBtn.style.display = "none";
}

// Hi·ªÉn th·ªã n√∫t s·∫µn s√†ng
function showReadyButton() {
    const readyBtn = document.getElementById('ready-btn');
    readyBtn.style.display = 'block';
    readyBtn.textContent = '‚úÖ S·∫µn s√†ng';
    readyBtn.classList.remove('ready');
}

// Th√™m v√†o l·ªãch s·ª≠
function addToHistory(choices, results) {
  const choiceNames = {
    rock: "B√∫a",
    paper: "Bao",
    scissors: "K√©o",
  };

  let historyText = "";
  for (const [playerName, choice] of Object.entries(choices)) {
    historyText += `${playerName}: ${choiceNames[choice]}`;
    if (
      Object.keys(choices).indexOf(playerName) <
      Object.keys(choices).length - 1
    ) {
      historyText += " vs ";
    }
  }

  const resultCounts = { win: 0, lose: 0, draw: 0 };
  for (const result of Object.values(results)) {
    resultCounts[result]++;
  }

  let resultSummary = "";
  if (resultCounts.win > 0) resultSummary += `${resultCounts.win} th·∫Øng `;
  if (resultCounts.lose > 0) resultSummary += `${resultCounts.lose} thua `;
  if (resultCounts.draw > 0) resultSummary += `${resultCounts.draw} h√≤a`;

  const historyItem = {
    text: `${historyText} - ${resultSummary}`,
    result:
      resultCounts.win > 0 ? "win" : resultCounts.lose > 0 ? "lose" : "draw",
  };

  gameHistory.unshift(historyItem);
  if (gameHistory.length > 10) {
    gameHistory.pop();
  }

  updateHistoryDisplay();
}

// C·∫≠p nh·∫≠t hi·ªÉn th·ªã l·ªãch s·ª≠
function updateHistoryDisplay() {
  const historyList = document.getElementById("history-list");
  historyList.innerHTML = "";

  gameHistory.forEach((item) => {
    const div = document.createElement("div");
    div.className = `history-item history-${item.result}`;
    div.textContent = item.text;
    historyList.appendChild(div);
  });
}

// L·∫•y text k·∫øt qu·∫£
function getResultText(result) {
  switch (result) {
    case "win":
      return "Th·∫Øng!";
    case "lose":
      return "Thua!";
    case "draw":
      return "H√≤a!";
    default:
      return "Kh√¥ng x√°c ƒë·ªãnh";
  }
}

// Hi·ªÉn th·ªã th√¥ng b√°o
function showNotification(message, type = "info") {
  const notification = document.getElementById("notification");
  notification.textContent = message;
  notification.className = `notification ${type} show`;

  setTimeout(() => {
    notification.classList.remove("show");
  }, 3000);
}

// Kh·ªüi t·∫°o khi trang load
document.addEventListener("DOMContentLoaded", () => {
  initWebSocket();
  updateHistoryDisplay();

  // T·ª± ƒë·ªông focus v√†o input t√™n
  document.getElementById("player-name").focus();
  //enter chat
  document.getElementById("chat-input").addEventListener("keypress", (e) => {
    if (e.key === "Enter") sendChat();
  });

  // Enter ƒë·ªÉ ƒë·∫∑t t√™n
  document.getElementById("player-name").addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
      setPlayerName();
    }
  });

  // Enter ƒë·ªÉ t·∫°o ph√≤ng
  document.getElementById("room-name").addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
      createRoom();
    }
  });
});

//h√†m g·ª≠i chat
function sendChat() {
  const input = document.getElementById("chat-input");
  const text = input.value.trim();
  if (!text) return;
  ws.send(
    JSON.stringify({
      type: "chat",
      message: text,
    })
  );
  input.value = "";
}

function addChatMessage(sender, message) {
  const chatBox = document.getElementById("chat-messages");
  if (!chatBox) return;

  const me = getMyServerName();
  const isMe = sender === me;
  const nameDisplay = isMe ? "B·∫°n" : sender;

  let cls = "chat-message";
  if (isMe) cls += " me";
  if (sender === "SYSTEM") cls += " system";

  const div = document.createElement("div");
  div.className = cls;
  div.innerHTML = `<b>${nameDisplay}:</b> ${message}`;
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
}

//th√™m gi·ªõi h·∫°n th·ªùi gian
function startCountdownTimer(duration = 10) {
  clearCountdownTimer();
  timeLeft = duration;
  hasChosenThisRound = false;
  document.getElementById("countdown-timer").style.display = "block";
  document.getElementById("timer-value").textContent = timeLeft;

  countdownInterval = setInterval(() => {
    timeLeft -= 1;
    document.getElementById("timer-value").textContent = timeLeft;
    if (timeLeft <= 0) {
      clearCountdownTimer();
      if (
        !hasChosenThisRound &&
        currentRoom &&
        currentRoom.room_name !== "B·∫°n vs M√°y"
      ) {
        // Random t·ª± ƒë·ªông ch·ªçn n·∫øu ch∆∞a ch·ªçn
        const randomChoices = ["rock", "paper", "scissors"];
        const autoChoice = randomChoices[Math.floor(Math.random() * 3)];
        sendChoice(autoChoice, true); // true = auto
      }
      // ·∫®n timer sau khi h·∫øt gi·ªù
      document.getElementById("countdown-timer").style.display = "none";
    }
  }, 1000);
}

function clearCountdownTimer() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  document.getElementById("countdown-timer").style.display = "none";
}
